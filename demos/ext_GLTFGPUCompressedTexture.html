<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GLTFGPUCompressedTexture Demo</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
    </style>
    <script src="https://cdn.bootcdn.net/ajax/libs/vConsole/3.3.4/vconsole.min.js"></script>
    <script>
      location.search.indexOf('?d=true') !== -1 && new VConsole();
    </script>
  </head>
  <body>
    <script type="module">
      import * as THREE from '../build/three.module.js';
      import { BrowserPlatform } from '../src/BrowserPlatform/index.js';
      import { GLTFLoader } from '../examples/jsm/loaders/GLTFLoader.js';
      import { GLTFGPUCompressedTexture } from '../extensions/GLTFGPUCompressedTexture.js';
      import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';
      // import { ZSTDDecoder } from '../examples/jsm/libs/zstddec.module.js';

      THREE.PLATFORM.set(new BrowserPlatform());

      const aspectRatio = innerWidth / innerHeight;
      const renderer = new THREE.WebGL1Renderer();
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 100);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const gltfLoader = new GLTFLoader();
      gltfLoader.register(
        parser => new GLTFGPUCompressedTexture(parser, renderer, true),
      );
      const useImageBitmapLoader =
        typeof createImageBitmap !== 'undefined' &&
        /Firefox/.test(navigator.userAgent) === false;

      console.log(
        `use ${useImageBitmapLoader ? 'ImageBitmapLoader' : 'TextureLoader'}`,
      );

      const baseUrl = 'http://127.0.0.1:8080';
      // const baseUrl = 'http://192.168.10.140:8080';
      const bagCases = [
        {
          uri: '/glb/Fendi_banzi_green.glb',
          name: 'first',
        },
        {
          uri: '/no-mipmap/Fendi_banzi_blue.gltf',
          name: 'gltf-tc zstd',
        },
        {
          uri: '/no-zstd/Fendi_banzi_blue.gltf',
          name: 'gltf-tc mipmap',
        },
        {
          uri: '/zstd/Fendi_banzi_blue.gltf',
          name: 'gltf-tc zstd mipmap',
        },
        {
          uri: '/glb/Fendi_banzi_blue.glb',
          name: 'glb',
        },
        {
          uri: '/gltf/Fendi_banzi_blue.gltf',
          name: 'gltf',
        },
      ];
      const BoomBoxCases = [
        {
          uri: '/zstd/BoomBox.gltf',
          name: 'gltf-tc BoomBox',
        },
        {
          uri: '/zstd/BoomBox.gltf',
          name: 'gltf-tc BoomBox no zstd decoder worker',
          noWorker: true,
        },
        {
          uri: '/glb/BoomBox.glb',
          name: 'glb BoomBox',
        },
        {
          uri: '/gltf/BoomBox.gltf',
          name: 'gltf BoomBox',
        },
      ];
      const cases = [
        {
          scale: 16,
          items: BoomBoxCases,
          offsetX: 0.5,
          offsetY: 0.4,
        },
        {
          scale: 2,
          items: bagCases,
          offsetX: 0.5,
          offsetY: 0.3,
        },
      ];

      let lastMap;

      const load = async () => {
        for (let i = 0; i < cases.length; i++) {
          for (let j = 0; j < cases[i].items.length; j++) {
            const { scale, offsetX, offsetY } = cases[i];
            const { name, noWorker, uri } = cases[i].items[j];

            await trackGroup(
              name,
              async () => {
                GLTFGPUCompressedTexture.useWorker = !noWorker;
                const gltf = await track('load', () =>
                  gltfLoader.loadAsync(baseUrl + uri),
                );
                gltf.parser = null;
                gltf.scene.position.y = 1.2 - j * offsetY;
                gltf.scene.position.x = -0.5 + i * offsetX;
                gltf.scene.scale.set(scale, scale, scale);
                scene.add(gltf.scene);
                // gltf.scene.traverse(node => {
                //   if (node.isMesh) {
                //     console.log(node);
                //   }
                // });
                track('renderer.compile', () => {
                  renderer.compile(scene, camera);
                });
                track('render', render);
                // track('render2', render);
                await sleep(200);
              },
              sumGroup,
            );
          }
        }

        render(true);
      };

      load();

      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      camera.position.z = 2;
      scene.background = new THREE.Color(0xffffff);
      scene.add(new THREE.AmbientLight(0xffffff, 1));
      scene.add(new THREE.DirectionalLight(0xffffff, 1));

      const render = rfa => {
        controls.update();
        renderer.render(scene, camera);
        rfa && requestAnimationFrame(render);
      };

      document.body.appendChild(renderer.domElement);
      render();

      function sleep(t) {
        return new Promise(r => setTimeout(r, t));
      }

      var currTrackInfo = {};
      async function track(name, fn) {
        const t = performance.now();
        const res = await fn();
        const cost = performance.now() - t;
        // console.log(name, cost);
        currTrackInfo[name] = cost;
        return res;
      }
      async function trackGroup(name, fn, sumFn) {
        console.log(`===========${name}===========`);
        currTrackInfo = {};
        await fn();
        sumFn(currTrackInfo);
        console.table(currTrackInfo);
      }
      function sumGroup(trackInfo) {
        // trackInfo.loadRender = trackInfo.load + trackInfo.render;
        console.log('sum', trackInfo.load + trackInfo.render);
      }

      //       const iframe = document.createElement('iframe');
      //       const html = `
      // <script>
      //   window.addEventListener('message', (e) => {
      //     console.log('iframe e', e)
      //   });

      //   let i = 0;
      //   setInterval(() => {
      //     window.postMessage(i++);
      //   }, 100)
      //   // while(1) {
      //   //   console.log('x')
      //   // }

      // <\/script>`;
      //       const blob = new Blob([html], { type: 'text/html' });
      //       iframe.src = URL.createObjectURL(blob);
      //       iframe.addEventListener('message', e => {
      //         console.log('main e', e);
      //       });
      //       document.body.append(iframe);
      //       iframe.contentWindow.postMessage('hello');
    </script>
  </body>
</html>
